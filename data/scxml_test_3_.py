
# autogenerated from /mnt/c/github/xml/data/scxml_test_3.scxml
import re
import time
import logging
from pathlib import Path
from functools import partial
from collections import namedtuple
from collections import OrderedDict

from miros import pp
from miros import Event
from miros import spy_on
from miros import signals
from miros import ActiveObject
from miros import return_status


@spy_on
def Start(self, e):
  status = return_status.UNHANDLED
  if(e.signal == signals.ENTRY_SIGNAL):
    self.post_fifo(Event(signal=signals.SCXML_INIT_SIGNAL))
    self.scribble("{} {}".format(self.var_list, type(self.var_list)))
    self.scribble("{} {}".format(self.var_str, type(self.var_str)))
    self.scribble("{} {}".format(self.var_int, type(self.var_int)))
    self.scribble("{} {}".format(self.var_bool, type(self.var_bool)))
    self.scribble("Hello from \"start\"")
    status = return_status.HANDLED
  elif(e.signal == signals.INIT_SIGNAL):
    status = return_status.HANDLED
  elif(e.signal == signals.SCXML_INIT_SIGNAL):
    status = self.trans(Work)
  elif(e.signal == signals.EXIT_SIGNAL):
    status = return_status.HANDLED
  else:
    self.temp.fun = self.top
    status = return_status.SUPER
  return status

@spy_on
def Work(self, e):
  status = return_status.UNHANDLED
  if(e.signal == signals.ENTRY_SIGNAL):
    self.scribble("Hello from \"work\"")
    status = return_status.HANDLED
  elif(e.signal == signals.INIT_SIGNAL):
    status = return_status.HANDLED
  elif(e.signal == signals.SCXML_INIT_SIGNAL):
    status = return_status.HANDLED
  elif(e.signal == signals.EXIT_SIGNAL):
    status = return_status.HANDLED
  else:
    self.temp.fun = self.top
    status = return_status.SUPER
  return status


class InstrumentedActiveObject(ActiveObject):
  def __init__(self, name, log_file):
    super().__init__(name)

    self.log_file = log_file

#    self.clear_log()

    logging.basicConfig(
      format='%(asctime)s %(levelname)s:%(message)s',
      filemode='w',
      filename=self.log_file,
      level=logging.DEBUG)
    self.register_live_spy_callback(partial(self.spy_callback))
    self.register_live_trace_callback(partial(self.trace_callback))

  def trace_callback(self, trace):
    '''trace without datetimestamp'''
    trace_without_datetime = re.search(r'(\[.+\]) (\[.+\].+)', trace).group(2)
    logging.debug("T: " + trace_without_datetime)

  def spy_callback(self, spy):
    '''spy with machine name pre-pending'''
    print(spy)
    logging.debug("S: [%s] %s" % (self.name, spy))

  def clear_log(self):
    with open(self.log_file, "w") as fp:
      fp.write("I'm writing")

class ScxmlChart(InstrumentedActiveObject):
  def __init__(self, name, log_file):
    super().__init__(name, log_file)
    self.var_bool = True
    self.var_int = 1
    self.var_str = "This is a string!"
    self.var_list = [1, 2, 3, 4, 5]

  def start(self):
    self.start_at(Start)

if __name__ == '__main__':
  ao = ScxmlChart("Scxml", "/mnt/c/github/xml/data/scxml_test_3.log")
  ao.live_spy = True
  ao.start()
  time.sleep(0.01)