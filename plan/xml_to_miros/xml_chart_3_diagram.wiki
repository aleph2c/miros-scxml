[[subgoals.xml_to_miros|back]]
*Xml Chart 3 Diagram*
= Observer ([[local:C:/Vim8.1/.vim/ooda.pdf|diagram]]) = 
== Evidence ([[evidence.xml_chart_3_diagram|evidence]]) ==

  *What defines Success?:* ([[subgoals.xml_chart_3_diagram|subgoals]])
   
    Have a clear set of instructions for how to place an orthogonal region
    within a statechart using the Miro Samek algorithm and the miros python
    library.
    
    These instructions will make it possible to implement the good parts of the
    SCXML standard.
    
  *What is the problem?*
  
    The xml chart diagram, describes features that aren't available within the
    miros library.  It contains orthogonal regions, which will be manifested
    with an orthogonal component strategy.
    
    We need to solve a general form of this diagram so we need to make sure the
    seed design is streamlined as much as possible.  If you start with a bad
    architecture, you will end up in hell.
    
    There are signal dynamics which break the orthogonal bounds between states
    -- see WTF signals.  Ensure your software can manage these signals.
    

  *Discoveries:* ([[notes.xml_chart_3_diagram|notes]])
  
   *Exceptions Needed:*
      
      If I'm in pp12_s12 and I block WTF1, but I'm also in pp12_s22 (which
      doesn't block WTF1), what do I do?  This seems like a contradiction or a
      broken formalism.
      
      So as a rule, we will not let parallel states block signals that are used
      by their other half.  We need to catch such situations and break the code
      on them.
      
  *Terminology*
  
    *Region*:  HsmWithQueues object with additional supporting methods
    
    *Regions*: Contains multiple Region objects in a collection, and it augments
             these regions so that they can reference each other using iterators.
             It adds `_post_fifo` and `_post_lifo` methods which can put items
             into all of it's inner region queues.
             It adds `post_fifo` and `post_lifo` method which will post items onto
             an inner queue, then drive the inner statecharts using their
             ``complete_circuit` method unit their queues are empty.
             
    *region dispatcher state*: `p` and `pp12` are states with the responsibility to drive
    events further into the regions which they encapsulate.  The region
    dispatcher states wrap an inner region of the chart. The region dispatcher
    state exists in an outer statechart from the regions they control.  They
    dispatch event to it using a reference to the `Regions` object and that
    object's `_post_fifo`, `post_fifo`, ... API.
   
    *hidden region state*:  A region statechart needs a hidden state, so that it
    can be transitioned to, without worry of an INIT_SIGNAL driving the action
    back into the center of the region again (if it is designed this way).  The
    hidden region is a outer holding state which by design does not have an
    INIT_SIGNAL handler.  The hidden region state exists within the statechart
    that manages a region.  There will be one per region.
    
    *region state*:  The immediate child state of a *hidden region state*, it's
    `INIT_SIGNAL` handler can initialize the region and can be programmed to
    respond to message provided by outer regions about how they need this inner
    region to respond, via the *init_stack* method.
    
    *init_stack*: A method which looking for `INIT_META` events in the region's
    queue.  If there is an `INIT_META` event waiting, it's payload is returned as
    a (e, state) tuple.  The `INIT_SIGNAL` handler will use this to decide how
    to initialize that region's state machine.
    
    *INIT_META*: an event which contains 0 or more *INIT_META* events and the
    states which are intended to handle these events.  They are injected into
    the queue of inner states so that their inner region state INIT handlers can
    programmatically initialize to a target provided by an outer region.
   
  *Passing events into inner regions*:
    
    An inner regions must have its events injected into it by an outer region or
    state machine.
    
    The `INIT_META` event was built to carry information into an inner region.
    This `INIT_META` event will be placed into the queue of the HSM for that
    region, and as such can be plucked out and interpreted by the `init_stack`
    
      To use an `INIT_META` signal, start from the deepest arrow head, and create an
      event with a signal name, `INIT_META` and provide it with a
      `INIT_META_PAYLOAD(event=None, state=<state required>)`, assume this named
      event is a.
      
      Then create an event b, with the signal name `INIT_META` and with a payload
      `INIT_META_PAYLOAD(event=a, state=<region_to_handle<state required>>)`
      
      ... continue until you get to the other arrow end
      
      The general pattern is:
        1) state handler which catches the initial signal:
        2) constructed nested `INIT_META` event
        3) post_fifo `INIT_META` into it's local queue
        4) transitions to the region dispatcher state (`p`, or ``pp12``)
        5) in the `INIT_SIGNAL` clause of the *region dispatcher state*, write:
        
          {{{
          elif(e.signal == signals.INIT_SIGNAL):
            (_e, _state) = self.init_stack(e)
              if _state:
                self.regions['p']._post_fifo(_e)
            self.regions['p'].post_lifo(Event(signal=signals.enter_region))
            status = return_status.HANDLED
          }}}
              
        6) in each inner *region state* functions write:
       
          {{{
          elif(e.signal == signals.INIT_SIGNAL):
            (_e, _state) = r.init_stack(e)  # search for INIT_META
            if _state is None or not r.has_a_child(_state):
              status = r.trans(<default state to transition to>)
            else:
              status = r.trans(_state)
              if not _e is None:
                r.post_fifo(_e)  # here we drive the next INIT_META if
                                 # required
          }}}
        
  *Passing events out of regions:*
  
  [[file:///C:/github/miros/docs/othogonalregions.html|old write up]]
  [[https://github.com/aleph2c/miros/blob/master/examples/xml_chart.py|old code]]
  
= Orient =
  *Symptoms:* [[symptoms.xml_chart_3_diagram|symptoms]]

== Questions ==
  *Questions for Xml Chart 3 Diagram: >= 5*
    Can you think of anyway to speed up your feedback cycle?
    Do you have enough information?
    Is your information organized?
    Can you reproduce the problem?
    Can you simplify your test?
    Do you have something to baseline from?
    What recently changed?
    What don't you know that you need to know?
  
  *Assumptions*

= Decide =
  [[#Questions]]
  *Research Needed For?:*
   
    Re-read David Harel's paper to see what he does about orthogonal transitions
    to answer the WTF1 contradiction.

  [[#Questions]]
  *Idea/Hypotheses for Xml Chart 3 Diagram: >=5*
  * [X] Find a way to reflect on the current active states [active_states()]
  * [X] Add asserts to the bottom of your file as a "car alarm" so if you break
        something while discovering against this file it will become obvious.
        with the chart
  * [X] Implement WFT1/E0, create terminology and an algorithm for how to pass
        events into inner regions.
  * [ ] Implement E1. go!
        
  * [ ] Implement a WTF2 signal on xml_chart_3.  See if you can find
        a simple pattern for doing this.
  * [ ] Consider leaving the orthogonal region to orthogonal component strategy
        for another one: see concurrent charts with publish/subscribe mappings
  * [ ] Clean up the instrumentation stream it's a mess
  * [ ] Find a way to leave and enter orthogonal regions recursively so that
        your topological pictures can be applied
  * [X] Create a comprehensive diagram to capture all topological targets, (but
        have you thought of everything)?
        
  *Chosen Research-Goal/Hypothesis*
    

== Plan ([[plan.xml_chart_3_diagram|plan]]) ==

= Act =
  

