[[subgoals.xml_to_miros|back]]
*Xml Chart 3 Diagram*
= Observer ([[local:C:/Vim8.1/.vim/ooda.pdf|diagram]]) = 
== Evidence ([[evidence.xml_chart_3_diagram|evidence]]) ==

  *What defines Success?:* ([[subgoals.xml_chart_3_diagram|subgoals]])
   
    Have a clear set of instructions for how to place an orthogonal region
    within a statechart using the Miro Samek algorithm and the miros python
    library.
    
  *What is the problem?*
  
    The xml chart diagram, describes features that aren't available within the
    miros library.  It contains orthogonal regions, which will be manifested
    with an orthogonal component strategy.
    
    We need to solve a general form of this diagram so we need to make sure the
    seed design is streamlined as much as possible.  If you start with a bad
    architecture, you will end up in hell.
    
    There are signal dynamics which break the orthogonal bounds between states
    Ensure your software can manage all possible typologies, see xml_chart_4.xml
    

  *Discoveries:* ([[notes.xml_chart_3_diagram|notes]])
  
     Inner states within inner regions will not be able to block signals that
     are managed by the outermost state.
      
      
  *Terminology*
  
    *Region*:  HsmWithQueues object with additional supporting methods
    
    *Regions*: Contains multiple Region objects in a collection, and it augments
             these regions so that they can reference each other using iterators.
             It adds `_post_fifo` and `_post_lifo` methods which can put items
             into all of it's inner region queues.
             It adds `post_fifo` and `post_lifo` method which will post items onto
             an inner queue, then drive the inner statecharts using their
             ``complete_circuit` method unit their queues are empty.
             
    *region dispatcher state*: `p` and `pp12` are states with the responsibility
    to drive events further into the regions which they encapsulate.  The region
    dispatcher states wrap an inner orthogonal component of the chart. The
    region dispatcher state exists in an outer statechart from the regions they
    control.  They dispatch event to it using a reference to the `Regions`
    object and that object's `_post_fifo`, `post_fifo`, ... API.
    
    *region state*:  The region state holds the entry, init and exit handlers
    for an entire regions.  Below it is the under_hidden state and above it is
    the over_hidden state and above that is the rest of the state machine for
    that region.
    
    The region state's `INIT_SIGNAL` can both initialize a region and respond to
    `INIT_META` events (programmable initialization information) with the help
    of the `init_stack` method.
    
    *hidden states*: A region will have two hidden states which sandwich the
    region state:
    1) under_hidden state (closes to the bottom of the chart)
    2) over_hidden state, on the other side of the region state
    
      *under_hidden state*: Presents the illusion that a region can be exited.
      It's a holding state with not initialization handler, and it is the
      outermost (bottom) state of a region.
      
      *over_hidden state*: Is a state which is used to for a regions
      re-initialization via the `force_region_init` event.  This is useful if
      you need to send META_INIT directives over the regional walls.
    
    *init_stack*: A method which looking for `INIT_META` events in the region's
    queue.  If there is an `INIT_META` event waiting, it's payload is returned as
    a (e, state) tuple.  The `INIT_SIGNAL` handler will use this to decide how
    to initialize that region's state machine.
    
    *INIT_META*: an event which contains 0 or more *INIT_META* events and the
    states which are intended to handle these events.  They are injected into
    the queue of inner states so that their inner region state INIT handlers can
    programmatically initialize to a target provided by an outer region.
   
  *Passing events into inner regions*:
    
    An inner regions must have its events injected into it by an outer region or
    state machine.
    
    The `INIT_META` event was built to carry information into an inner region.
    This `INIT_META` event will be placed into the queue of the HSM for that
    region, and as such can be plucked out and interpreted by the `init_stack`
    
      To use an `INIT_META` signal, start from the deepest arrow head, and create an
      event with a signal name, `INIT_META` and provide it with a
      `INIT_META_PAYLOAD(event=None, state=<state required>)`, assume this named
      event is a.
      
      Then create an event b, with the signal name `INIT_META` and with a payload
      `INIT_META_PAYLOAD(event=a, state=<region_to_handle<state required>>)`
      
      ... continue until you get to the other arrow end
      
      The general pattern is:
        1) state handler which catches the initial signal:
        2) constructed nested `INIT_META` event
        3) post_fifo `INIT_META` into it's local queue
        4) transitions to the region dispatcher state (`p`, or ``pp12``)
        5) in the `INIT_SIGNAL` clause of the *region dispatcher state*, write:
        
          {{{
          elif(e.signal == signals.INIT_SIGNAL):
            (_e, _state) = self.init_stack(e)
              if _state:
                self.regions['p']._post_fifo(_e)
            self.regions['p'].post_lifo(Event(signal=signals.enter_region))
            status = return_status.HANDLED
          }}}
              
        6) in each inner *region state* functions write:
       
          {{{
          elif(e.signal == signals.INIT_SIGNAL):
            (_e, _state) = r.init_stack(e)  # search for INIT_META
            if _state is None or not r.has_a_child(_state):
              status = r.trans(<default state to transition to>)
            else:
              status = r.trans(_state)
              if not _e is None:
                r.post_fifo(_e)  # here we drive the next INIT_META if
                                 # required
          }}}
          
    *How to build a INIT_META event*:
    
      To use an `INIT_META` signal, start from the deepest arrow head, and create an
      event with a signal name, `INIT_META` and provide it with a
      `INIT_META_PAYLOAD(event=None, state=<state required>)`, assume this named
      event is a.
      
        
  *Passing events out of regions:*
  
  [[file:///C:/github/miros/docs/othogonalregions.html|old write up]]
  [[https://github.com/aleph2c/miros/blob/master/examples/xml_chart.py|old code]]
  
= Orient =
  *Symptoms:* [[symptoms.xml_chart_3_diagram|symptoms]]

== Questions ==
  *Questions for Xml Chart 3 Diagram: >= 5*
    Can you think of anyway to speed up your feedback cycle?
    Do you have enough information?
    Is your information organized?
    Can you reproduce the problem?
    Can you simplify your test?
    Do you have something to baseline from?
    What recently changed?
    What don't you know that you need to know?
  
  *Assumptions*

= Decide =
  [[#Questions]]
  *Research Needed For?:*
   
    Re-read David Harel's paper to see what he does about orthogonal transitions
    to answer the WTF1 contradiction.

  [[#Questions]]
  *Idea/Hypotheses for Xml Chart 3 Diagram: >=5*
  * [X] Find a way to reflect on the current active states [active_states()]
  * [X] Add asserts to the bottom of your file as a "car alarm" so if you break
        something while discovering against this file it will become obvious.
        with the chart
  * [X] Implement WFT1/E0, create terminology and an algorithm for how to pass
        events into inner regions.
  * [ ] Figure out theory of META_INIT
  * [ ] Implement E1. go!
        
  * [ ] Implement a WTF2 signal on xml_chart_3.  See if you can find
        a simple pattern for doing this.
  * [ ] Consider leaving the orthogonal region to orthogonal component strategy
        for another one: see concurrent charts with publish/subscribe mappings
  * [ ] Clean up the instrumentation stream it's a mess
  * [ ] Find a way to leave and enter orthogonal regions recursively so that
        your topological pictures can be applied
  * [X] Create a comprehensive diagram to capture all topological targets, (but
        have you thought of everything)?
        
  *Chosen Research-Goal/Hypothesis*
    

== Plan ([[plan.xml_chart_3_diagram|plan]]) ==

= Act =
  

