[[subgoals.parallel|back]]
*Parallel Example 4*
= Observer ([[local:C:/Vim8.1/.vim/ooda.pdf|diagram]]) =
== Evidence ([[evidence.parallel_example_4|evidence]]) ==

  *What defines Success?:* ([[subgoals.parallel_example_4|subgoals]])

    Get F1 working cleanly

  *What is the problem?*

    The code had to be change quite a bit to make F1 work, now clean it up and
    generalize your solution.

  *Discoveries:* ([[notes.parallel_example_4|notes]])
  
    Injectors:
      * [ ] p
      * [ ] p_p11
      * [ ] p_p12
      * [ ] p_p12_p11
      * [ ] p_p22
  
    Construction notes:
      * Move in native code
      * Add regions to the XmlChart Constructor
      * Follow under hidden, region, over hidden recipe
        * [ ] add INIT_SIGNAL code
        * [ ] add EXIT_META_SIGNAL
        * [ ] add INIT_META_SIGNAL hook
      * Find your injectors 
        * [ ] add special entry code
        * [ ] add special EXIT_META_SIGNAL code
        * [ ] add injection code
        * [ ] add exit region handler
    
    Found that if an injector EXIT posted exit_region to inners, some events
    didn't work.

    Region notes:

      elif(e.signal == signals.INIT_SIGNAL):
        # search for INIT_META_SIGNAL
        (_e, _state) = r.meta_peel(e)

        # If the target state is this state, just strip this layer of
        # the meta event and use the next one (this was done to make the
        # meta events consistent and easy to read and usable by different
        # types of WTF events.
        if _state == <region_state>:
          (_e, _state) = _e.payload.event, _e.payload.state

        # if _state is a child of this state then transition to it
        if _state is None or not r.has_a_child(<region_state>, _state):
          status = r.trans(<default_init_state>)
        else:
          status = r.trans(_state)
          if _e is not None:
            r.post_fifo(_e)
      elif(e.signal == signals.EXIT_META_SIGNAL):
        (_e, _state) = e.payload.event, e.payload.state
        if r.has_a_child(<region_state>, _state):
          r.outer.post_fifo(_e)
        status = return_status.HANDLED
      elif(e.signal == signals.exit_region):
        status = r.trans(<region>_under_hidden_region)
      elif(e.signal == signals.INIT_META_SIGNAL):
        status = return_status.HANDLED
      elif(e.signal == signals.EXIT_SIGNAL):
        pprint("exit <region_state>")
        status = return_status.HANDLED
      else:
        r.temp.fun = p_r1_under_hidden_region
        status = return_status.SUPER
      return status

    Injector notes:

      if(e.signal == signals.ENTRY_SIGNAL):
        pprint("enter <injector_state>")
        # search for INIT_META_SIGNAL
        (_e, _state) = r.meta_peel(e)
        if _state:
          r.inner._post_fifo(_e)
        r.inner.post_lifo(Event(signal=signals.enter_region))
        status = return_status.HANDLED
      elif e.signal == signals.EXIT_META_SIGNAL:
        (_e, _state) = e.payload.event, e.payload.state
        if r.has_a_child(<injector_state>, _state):
          # The next state is going to be our region handler skip it and post this
          # region handler would have posted to the outer HSM
          (_e, _state) = _e.payload.event, _e.payload.state
          r.outer.post_lifo(_e)
        status = return_status.HANDLED
      elif e.signal == signals.exit_region:
        r.scribble(Event(e.signal_name))
        #post_lifo(Event(signal=signals.exit_region))
        status = r.trans(<region_state_name>_hidden_region)

    The use of the rr.fns dict has made it harder to troubleshoot problems
    because I can not grep and search for the functions I want to search for
    directly.  Try to make your code grep-able.

= Orient =
  *Symptoms:* [[symptoms.parallel_example_4|symptoms]]

== Questions ==
  *Questions for Parallel Example 4: >= 5*

  *Assumptions*

= Decide =

  [[#Questions]]
  *Research Needed For?:*
  * [ ] Look at the code first before you begin the port.  Then envision a plan
        of attack.

  [[#Questions]]
  *Idea/Hypotheses for Parallel Example 4: >=5*
  * [ ] Diff the file and look for the work that has to be done

  *Chosen Research-Goal/Hypothesis*
  * [ ] Diff the file 
  * [ ] 

== Plan ([[plan.parallel_example_4|plan]]) ==

= Act =
