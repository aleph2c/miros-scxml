[[subgoals.parallel|back]]
*Parallel Example 4*
= Observer ([[local:C:/Vim8.1/.vim/ooda.pdf|diagram]]) =
== Evidence ([[evidence.parallel_example_4|evidence]]) ==

  *What defines Success?:* ([[subgoals.parallel_example_4|subgoals]])

    Have a working I1 event.

  *What is the problem?*

    The I1 event should not exit p_r1_region and enter p_r1_region.  It has gone
    out too far.

    Double-check other bounce signals to see if they too are going out too far.

    Double-check other WTF events using print statements, verify there
    entry/exit pathing is what you expect.

  *Discoveries:* ([[notes.parallel_example_4|notes]])

    *Warnings*

    Since the state functions are decoratored, it is very tricky to compare the
    using the '==' operator.  Technically speaking, a decorated function and its
    naked version are not equivalent.  To avoid what could be a very nasty and
    hard to track bug, compare the string names of function not the functions
    directly.

    Do not use post_fifo or post_lifo within mini-steps.  Instead use _post_fifo
    and _post_lifo and let the driver push all of the intermediate events
    through the chart.

    The use of the rr.fns dict has made it harder to troubleshoot problems
    because I can not grep and search for the functions I want to search for
    directly.  Try to make your code grep-able.

    *Future Goals*:

      If you are tired, pick an easy goal, if you are fresh pick a hard goal

      *Easy Goals:*
      * [ ] Remove references to outmost for final_signal_name handling, use
            same, inner or outer attributes instead. (figure out which is
            appropriate)
      * [ ] Write up trouble shooting method for tracking WTF event
      * [ ] Understand how the logging system works for working WTF events.
      * [ ] Find a way to make E2 handling consistent with the other WTF events
            in the system. (see p_p12)
      * [ ] Add a filter function which will accept a list of string which will
            work with the token_match, to let or stop events from being injected
            into an inner parallel region.
      * [ ] Integrate build_onion into meta_init
      * [ ] Integrate meta_init into meta_trans

      *Harder Goals:*
      * [ ] Refactor the logging system to be intuitive.
      * [ ] Need a mechanism to clear the graph's cache.  This will be needed
            when an XML diagram is being used to over-write and inner part of a
            program.
      * [ ] Construct new topological graph, with and without duplicate WTF
            events.

    Pre-made check lists for consistency work:

    Injectors:
      * [ ] p (active object)
      * [X] p_p11 (Region)
      * [X] p_p12 (Region)
      * [X] p_p12_p11 (Region)
      * [ ] p_p22 (Region)

    Region State Functions:
      * [ ] p_p11_r1_region
      * [ ] p_p12_p11_r1_region
      * [ ] p_p11_r2_region
      * [ ] p_p12_p11_r1_region
      * [ ] p_p12_p11_r2_region
      * [ ] p_p12_r1_region
      * [ ] p_p12_r2_region
      * [ ] p_p22_r1_region
      * [ ] p_p22_r2_region
      * [ ] p_r1_region
      * [ ] p_r2_region

    Under Region State Functions:
      * [ ] p_p11_r1_under_hidden_region
      * [ ] p_p11_r2_under_hidden_region
      * [ ] p_p12_p11_r1_under_hidden_region
      * [ ] p_p12_p11_r2_under_hidden_region
      * [ ] p_p12_r1_under_hidden_region
      * [ ] p_p12_r2_under_hidden_region
      * [ ] p_p22_r1_under_hidden_region
      * [ ] p_p22_r2_under_hidden_region
      * [ ] p_r1_under_hidden_region
      * [ ] p_r2_under_hidden_region

    Over Region State Functions:
      * [ ] p_p11_r1_over_hidden_region
      * [ ] p_p11_r2_over_hidden_region
      * [ ] p_p12_p11_r1_over_hidden_region
      * [ ] p_p12_p11_r2_over_hidden_region
      * [ ] p_p12_r1_over_hidden_region
      * [ ] p_p12_r2_over_hidden_region
      * [ ] p_p22_r1_over_hidden_region
      * [ ] p_p22_r2_over_hidden_region
      * [ ] p_r1_over_hidden_region
      * [ ] p_r2_over_hidden_region

    Active Object States:
      * [ ] outer_state
      * [ ] p (injector)
      * [ ] some_other_state

    Other Region States (not injectors or regions):
      * [ ] p_p11_r1_final
      * [ ] p_p11_r1_over_hidden_region
      * [ ] p_p11_r1_under_hidden_region
      * [ ] p_p11_r2_final
      * [ ] p_p11_r2_over_hidden_region
      * [ ] p_p11_r2_under_hidden_region
      * [ ] p_p11_s11
      * [ ] p_p11_s12
      * [ ] p_p11_s21
      * [ ] p_p11_s22
      * [ ] p_p12_p11
      * [ ] p_p12_p11_r1_over_hidden_region
      * [ ] p_p12_p11_r1_under_hidden_region
      * [ ] p_p12_p11_r2_over_hidden_region
      * [ ] p_p12_p11_r2_under_hidden_region
      * [ ] p_p12_p11_s11
      * [ ] p_p12_p11_s12
      * [ ] p_p12_p11_s21
      * [ ] p_p12_r1_final
      * [ ] p_p12_r1_over_hidden_region
      * [ ] p_p12_r1_under_hidden_region
      * [ ] p_p12_r2_final
      * [ ] p_p12_r2_over_hidden_region
      * [ ] p_p12_r2_under_hidden_region
      * [ ] p_p12_s12
      * [ ] p_p12_s21
      * [ ] p_p12_s22
      * [ ] p_p22_r1_final
      * [ ] p_p22_r1_over_hidden_region
      * [ ] p_p22_r1_under_hidden_region
      * [ ] p_p22_r2_final
      * [ ] p_p22_r2_over_hidden_region
      * [ ] p_p22_r2_under_hidden_region
      * [ ] p_p22_s11
      * [ ] p_p22_s12
      * [ ] p_p22_s21
      * [ ] p_p22_s22
      * [ ] p_r1_final
      * [ ] p_r1_over_hidden_region
      * [ ] p_r1_region
      * [ ] p_r1_under_hidden_region
      * [ ] p_r2_final
      * [ ] p_r2_over_hidden_region
      * [ ] p_r2_region
      * [ ] p_r2_under_hidden_region
      * [ ] p_s21

    Region notes:


= Orient =
  *Symptoms:* [[symptoms.parallel_example_4|symptoms]]

  *Assumptions (at first invisible)*
    To find your assumptions, look for two peices of evidence that contradict
    each other. (may have to wait a couple of loops)

  *Questions for :*

  === Pre trouble-shooting questions ===
    * [ ] Do you have enough information?
    * [ ] Is your information organized?
    * [ ] Can you draw a diagram of the components and their interactions?
    * [ ] Do you need to write some code to make it easier to see?
    * [ ] Can you think of anyway to speed up your feedback cycle?

    * [ ] Is it a repair or a pioneering problem?  Did it work once before, or did it
          work somewhere else?  Yes: Repair, No: Pioneering.

  === Repair (Complexity increases exponentially) ===
    * [ ] Can you test the individual components to reduce complexity?
    * [ ] Can you exchange components?
    * [ ] Can you reduce the number of interactions?
    * [ ] Are you continuing event though you know that something you have previously
          tested isn't working?
    * [ ] Has a thing you have previously tested fooled you into thinking it works,
          when it doesn't work? (Never assume something is right before you have
          checked it twice)

  == Pioneering ==
    * [ ] Has someone else solved this before (search)? Can you turn this into a
          repair?
    * [ ] Do you have something to baseline from?
    * [ ] Looking under the problem, are you focused on the right goals?  Are you
          stuck on solving a hard problem, when there is an easy problem?
    * [ ] Do you understand how your existing system works?  If not, can you draw
          diagrams and describe how it works before you continue?
    * [ ] What don't you know that you need to know?

  == Custom Questions: (>=5) ==
    * [ ] Can you brute force it?

= Decide =

  [[#Questions]]
  *Research Needed For?:*

  [[#Questions]]
  *Idea/Hypotheses for Parallel Example 4: >=5*

  *Chosen Research-Goal/Hypothesis*

== Plan ([[plan.parallel_example_4|plan]]) ==

= Act =
