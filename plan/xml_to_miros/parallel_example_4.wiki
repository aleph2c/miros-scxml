[[subgoals.parallel|back]]
*Parallel Example 4*
= Observer ([[local:C:/Vim8.1/.vim/ooda.pdf|diagram]]) =
== Evidence ([[evidence.parallel_example_4|evidence]]) ==

  *What defines Success?:* ([[subgoals.parallel_example_4|subgoals]])
    Add the F0, B0 WTF events

  *What is the problem?*
    These features aren't implemented yet.

  *Discoveries:* ([[notes.parallel_example_4|notes]])

    *How To:*

    To track a meta event (1-4 takes about 10 minutes to set up):
      1. place a print(ps(_e)) at it's source
      2. write out a list in this document, one line for each line of the above
         output... associate each line with a Vim marker, {a, b, c, ... }
      3. for each line in this listing go to the corresponding location in the
         code and add an 'investigate(r, e, _e)'.  Assign the proper marker
      4. add a time delay after the broken test in the outer program so that you
         can break into the statechart thread and the program will continue to
         run.
      5. for each step look at the log and look poke around in the investigate
         location of the marked spot.

    *Warnings:*

    The lazy-inners thing is causing me trouble now (can you make this go away?)

    Since the state functions are decoratored, it is very tricky to compare the
    using the '==' operator.  Technically speaking, a decorated function and its
    naked version are not equivalent.  To avoid what could be a very nasty and
    hard to track bug, compare the string names of function not the functions
    directly. (You can use the __wrapped__ magic method!)

    Do not use post_fifo or post_lifo within mini-steps.  Instead use _post_fifo
    and _post_lifo and let the driver push all of the intermediate events
    through the chart.

    The use of the rr.fns dict has made it harder to troubleshoot problems
    because I can not grep and search for the functions I want to search for
    directly.  Try to make your code grep-able.

    *Future Goals*:

      If you are tired, pick an easy goal, if you are fresh pick a hard goal

      *Easy Goals:*
      * [ ] Audit the entry/exit conditions for every WTF.  Create a bug listing
            for anything that needs to be fixed.
      * [ ] Remove references to outmost for final_signal_name handling, use
            same, inner or outer attributes instead. (figure out which is
            appropriate)
      * [ ] Write up trouble shooting method for tracking WTF event
      * [ ] Integrate build_onion into meta_init
      * [ ] Integrate meta_init into meta_trans

      *Harder Goals:*
      * [ ] Add META_HOOKS
      * [ ] Exclusive Transitions into a parallel state. (this will require a
            change in the drawing techniques)
      * [ ] Create a new, comprehensive topological map, refactor your existing
            code until you can map all WTF events.  Include duplicate WTF
            events.
      * [ ] Turn meta_trans into an HSM
      * [ ] Adjust the log output to look like the print output
      * [ ] Move the meta_init, meta_trans and all of surrounding minor event
            drivers into one API.  The idea here is to make the interface
            extremely easy to use.
      * [ ] Need a mechanism to clear the graph's cache.  This will be needed
            when an XML diagram is being used to over-write and inner part of a
            program.

    Pre-made check lists for consistency work:

    Injectors:
      * [ ] p (active object)
      * [ ] p_p11 (Region)
      * [ ] p_p12 (Region)
      * [ ] p_p12_p11 (Region)
      * [ ] p_p22 (Region)

    Outer Injectors:
      * [ ] p (active object)

    Inner Injectors:
      * [ ] p_p11 (Region)
      * [ ] p_p12 (Region)
      * [ ] p_p12_p11 (Region)
      * [ ] p_p22 (Region)

    Region State Functions:
      * [ ] p_p11_r1_region
      * [ ] p_p12_p11_r1_region
      * [ ] p_p11_r2_region
      * [ ] p_p12_p11_r1_region
      * [ ] p_p12_p11_r2_region
      * [ ] p_p12_r1_region
      * [ ] p_p12_r2_region
      * [ ] p_p22_r1_region
      * [ ] p_p22_r2_region
      * [ ] p_r1_region
      * [ ] p_r2_region

    Under Region State Functions:
      * [ ] p_p11_r1_under_hidden_region
      * [ ] p_p11_r2_under_hidden_region
      * [ ] p_p12_p11_r1_under_hidden_region
      * [ ] p_p12_p11_r2_under_hidden_region
      * [ ] p_p12_r1_under_hidden_region
      * [ ] p_p12_r2_under_hidden_region
      * [ ] p_p22_r1_under_hidden_region
      * [ ] p_p22_r2_under_hidden_region
      * [ ] p_r1_under_hidden_region
      * [ ] p_r2_under_hidden_region

    Over Region State Functions:
      * [ ] p_p11_r1_over_hidden_region
      * [ ] p_p11_r2_over_hidden_region
      * [ ] p_p12_p11_r1_over_hidden_region
      * [ ] p_p12_p11_r2_over_hidden_region
      * [ ] p_p12_r1_over_hidden_region
      * [ ] p_p12_r2_over_hidden_region
      * [ ] p_p22_r1_over_hidden_region
      * [ ] p_p22_r2_over_hidden_region
      * [ ] p_r1_over_hidden_region
      * [ ] p_r2_over_hidden_region

    Active Object States:
      * [ ] outer_state
      * [ ] p (injector)
      * [ ] some_other_state

    Other Region States (not injectors or regions):
      * [ ] p_p11_r1_final
      * [ ] p_p11_r1_over_hidden_region
      * [ ] p_p11_r1_under_hidden_region
      * [ ] p_p11_r2_final
      * [ ] p_p11_r2_over_hidden_region
      * [ ] p_p11_r2_under_hidden_region
      * [ ] p_p11_s11
      * [ ] p_p11_s12
      * [ ] p_p11_s21
      * [ ] p_p11_s22
      * [ ] p_p12_p11
      * [ ] p_p12_p11_r1_over_hidden_region
      * [ ] p_p12_p11_r1_under_hidden_region
      * [ ] p_p12_p11_r2_over_hidden_region
      * [ ] p_p12_p11_r2_under_hidden_region
      * [ ] p_p12_p11_s11
      * [ ] p_p12_p11_s12
      * [ ] p_p12_p11_s21
      * [ ] p_p12_r1_final
      * [ ] p_p12_r1_over_hidden_region
      * [ ] p_p12_r1_under_hidden_region
      * [ ] p_p12_r2_final
      * [ ] p_p12_r2_over_hidden_region
      * [ ] p_p12_r2_under_hidden_region
      * [ ] p_p12_s12
      * [ ] p_p12_s21
      * [ ] p_p12_s22
      * [ ] p_p22_r1_final
      * [ ] p_p22_r1_over_hidden_region
      * [ ] p_p22_r1_under_hidden_region
      * [ ] p_p22_r2_final
      * [ ] p_p22_r2_over_hidden_region
      * [ ] p_p22_r2_under_hidden_region
      * [ ] p_p22_s11
      * [ ] p_p22_s12
      * [ ] p_p22_s21
      * [ ] p_p22_s22
      * [ ] p_r1_final
      * [ ] p_r1_over_hidden_region
      * [ ] p_r1_region
      * [ ] p_r1_under_hidden_region
      * [ ] p_r2_final
      * [ ] p_r2_over_hidden_region
      * [ ] p_r2_region
      * [ ] p_r2_under_hidden_region
      * [ ] p_s21

    Region notes:

= Orient =
  *Symptoms:* [[symptoms.parallel_example_4|symptoms]]

  *Assumptions (at first invisible)*
    To find your assumptions, look for two pieces of evidence that contradict
    each other. (may have to wait a couple of loops)

  *Questions for :*

  === Pre trouble-shooting questions ===
    * [ ] Do you have enough information?
    * [ ] Is your information organized?
    * [ ] Can you draw a diagram of the components and their interactions?
    * [ ] Do you need to write some code to make it easier to see?
    * [ ] Can you think of anyway to speed up your feedback cycle?

    * [ ] Is it a repair or a pioneering problem?  Did it work once before, or did it
          work somewhere else?  Yes: Repair, No: Pioneering.

  === Repair (Complexity increases exponentially) ===
    * [ ] Can you test the individual components to reduce complexity?
    * [ ] Can you exchange components?
    * [ ] Can you reduce the number of interactions?
    * [ ] Are you continuing event though you know that something you have previously
          tested isn't working?
    * [ ] Has a thing you have previously tested fooled you into thinking it works,
          when it doesn't work? (Never assume something is right before you have
          checked it twice)

  == Pioneering ==
    * [ ] Has someone else solved this before (search)? Can you turn this into a
          repair?
    * [ ] Do you have something to baseline from?
    * [ ] Looking under the problem, are you focused on the right goals?  Are you
          stuck on solving a hard problem, when there is an easy problem?
    * [ ] Do you understand how your existing system works?  If not, can you draw
          diagrams and describe how it works before you continue?
    * [ ] What don't you know that you need to know?

  == Custom Questions: (>=5) ==
    * [ ] Can you brute force it?
    * [ ] Can you change the bounce and trans signals to make them consistently
          named?
    * [ ] Can you find a way to detect this kind of transition, without damaging
          the existing WTF infrastructure?
    * [ ] Did you generalize the outer_state function knowledge from your last
          push?

= Decide =

  [[#Questions]]
  *Research Needed For?:*

  [[#Questions]]
  *Idea/Hypotheses for Parallel Example 4: >=5*

  *Chosen Research-Goal/Hypothesis*

== Plan ([[plan.parallel_example_4|plan]]) ==

= Act =
